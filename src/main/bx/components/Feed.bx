/**
 * BoxLang Feed Component - Compatible with CFML cffeed tag
 * <p>
 * This component provides RSS and Atom feed reading and creation capabilities.
 * It supports two actions: "read" (parse existing feeds) and "create" (generate new feeds).
 * <p>
 * Basic Usage - Read Action:
 * <pre>
 * <bx:Feed
 *     action="read"
 *     source="https://example.com/feed.xml"
 *     result="feedData" />
 * </pre>
 * <p>
 * Read Action - Multiple Outputs (can use any combination):
 * <pre>
 * <bx:Feed
 *     action="read"
 *     source="https://example.com/feed.xml"
 *     result="feedData"
 *     properties="feedMetadata"
 *     query="feedItems"
 *     xmlVar="rawXml"
 *     outputFile="/path/to/feed.xml" />
 * </pre>
 * <p>
 * Basic Usage - Create Action:
 * <pre>
 * <bx:Feed
 *     action="create"
 *     properties="#feedProperties#"
 *     data="#feedItems#"
 *     xmlVar="feedXml"
 *     outputFile="/path/to/feed.xml" />
 * </pre>
 * <p>
 * @attribute.action - string, required - Action to perform: "read" or "create". Default: "read"
 * @attribute.source - string, required for read - URL or file path to the feed to read
 * @attribute.result - string, optional - Variable name to store the full feed structure (read action)
 * @attribute.name - struct/string - For read: output variable name (alias for result). For create: input struct containing full feed (alternative to properties+data)
 * @attribute.properties - struct/string - For create: feed metadata (title, description, link, etc.). For read: output variable for channel metadata only
 * @attribute.data - array/query, required for create (unless name provided) - Feed items/entries
 * @attribute.query - any - For create: deprecated alias for "data". For read: output variable for items as query
 * @attribute.columnMap - struct, optional - Map query columns to feed fields (for query data)
 * @attribute.outputFile - string, optional - File path to write the feed XML (both read and create actions)
 * @attribute.overwrite - boolean, optional - Whether to overwrite existing file. Default: false
 * @attribute.xmlVar - string, optional - Variable name to store the raw XML string (both read and create actions)
 * @attribute.timeout - numeric, optional - HTTP timeout in seconds. Default: 60
 * @attribute.userAgent - string, optional - Custom User-Agent for HTTP requests
 * @attribute.escapeChars - boolean, optional - Escape special characters in create action. Default: false
 */
import bxModules.bxrss.models.FeedUtil;
import java:ortus.boxlang.runtime.dynamic.ExpressionInterpreter;

@BoxComponent( "Feed" )
@AllowsBody( false )
@RequiresBody( false )
class{

	/**
	 * --------------------------------------------------------------------------
	 * Injections
	 * --------------------------------------------------------------------------
	 */
	property name="moduleRecord";
	property name="boxRuntime";
	property name="functionService";
	property name="componentService";
	property name="interceptorService";
	property name="asyncService";
	property name="schedulerService";
	property name="datasourceService";
	property name="cacheService";
	property name="log";

	/**
	 * Main invoke method - routes to read or create action
	 *
	 * @param context The context of the execution (IBoxContext)
	 * @param attributes The attributes of the component that were passed in
	 * @param body The body of the component (not used)
	 * @param executionState The execution state of the component
	 *
	 * @return A BodyResult instance or null for a default result return
	 */
	function invoke( required context, Struct attributes, any body, Struct executionState ){
		// Get action (default to "read")
		var action = attributes.action ?: "read"

		// Handle backward compatibility
		// For read action: name is alias for result (output variable)
		if( action == "read" && structKeyExists( attributes, "name" ) && !structKeyExists( attributes, "result" ) ) {
			attributes.result = attributes.name
		}

		// For create action: name can be input structure (alternative to properties+data)
		if( action == "create" && structKeyExists( attributes, "name" ) && isStruct( attributes.name ) ) {
			// Extract properties from name structure (all keys except 'item')
			if( !structKeyExists( attributes, "properties" ) ) {
				attributes.properties = {}
				for( var key in attributes.name ) {
					if( key != "item" && key != "items" ) {
						attributes.properties[ key ] = attributes.name[ key ]
					}
				}
			}
			// Extract items from name.item or name.items
			if( !structKeyExists( attributes, "data" ) ) {
				if( structKeyExists( attributes.name, "item" ) ) {
					attributes.data = attributes.name.item
				} else if( structKeyExists( attributes.name, "items" ) ) {
					attributes.data = attributes.name.items
				}
			}
		}

		// Handle query as alias for data
		if( structKeyExists( attributes, "query" ) && !structKeyExists( attributes, "data" ) ) {
			attributes.data = attributes.query
		}

		// Route to appropriate action
		if( action == "create" ) {
			createAction( context, attributes )
		} else if( action == "read" ) {
			readAction( context, attributes )
		} else {
			throw(
				type="InvalidAction",
				message="Invalid action '#action#'. Must be 'read' or 'create'."
			)
		}
	}

	/**
	 * Read action - Parse an RSS/Atom feed from URL or file
	 */
	private function readAction( required context, required struct attributes ) {
		// Validate required attributes
		if( !structKeyExists( attributes, "source" ) ) {
			throw(
				type="MissingAttribute",
				message="The 'source' attribute is required for read action."
			)
		}

		// Get optional parameters with defaults
		var timeout = attributes.timeout ?: 60
		var userAgent = attributes.userAgent ?: ""
		var maxItems = attributes.maxItems ?: 0
		var itunes = attributes.itunes ?: false
		var mediaRss = attributes.mediaRss ?: false

		// Call FeedUtil.readFeed()
		var feedData = FeedUtil.readFeed(
			urls = attributes.source,
			maxItems = maxItems,
			itunes = itunes,
			mediaRss = mediaRss,
			userAgent = userAgent,
			timeout = timeout
		)

		// Output to various destinations as requested (can use any combination)

		// 1. Output full structure to result or name variable
		if( structKeyExists( attributes, "result" ) ) {
			ExpressionInterpreter.setVariable( context, attributes.result, feedData );
		}

		// 2. Output metadata to properties variable
		if( structKeyExists( attributes, "properties" ) && isSimpleValue( attributes.properties ) ) {
			ExpressionInterpreter.setVariable( context, attributes.properties, feedData.channel );
		}

		// 3. Output items to query variable
		if( structKeyExists( attributes, "query" ) && isSimpleValue( attributes.query ) ) {
			ExpressionInterpreter.setVariable( context, attributes.query, feedData.items );
		}

		// 4. Output raw XML to xmlVar
		if( structKeyExists( attributes, "xmlVar" ) ) {
			var rawXml = getRawXml( attributes.source, userAgent, timeout );
			ExpressionInterpreter.setVariable( context, attributes.xmlVar, rawXml );
		}

		// 5. Write raw XML to outputFile
		if( structKeyExists( attributes, "outputFile" ) ) {
			var filePath = attributes.outputFile;
			var overwrite = attributes.overwrite ?: false;

			// Check if file exists and overwrite is false
			if( fileExists( filePath ) && !overwrite ) {
				throw(
					type="FileExists",
					message="File '#filePath#' already exists. Set overwrite=true to replace it."
				);
			}

			// Get raw XML and write to file
			var rawXml = getRawXml( attributes.source, userAgent, timeout );
			fileWrite( filePath, rawXml );
		}
	}

	/**
	 * Helper: Fetch raw XML from source
	 */
	private function getRawXml( required string source, string userAgent="", numeric timeout=60 ) {
		// Check if source is URL or file path
		if( findNoCase( "http://", source ) == 1 || findNoCase( "https://", source ) == 1 ) {
			// HTTP request using BoxLang http component
			bx:http
				url = source
				method = "GET"
				timeout = timeout
				userAgent = userAgent
				result = "httpResult";

			return httpResult.fileContent;
		} else {
			// Local file
			return fileRead( source );
		}
	}

	/**
	 * Create action - Generate an RSS/Atom feed from properties and data
	 */
	private function createAction( required context, required struct attributes ) {
		// Validate required attributes
		if( !structKeyExists( attributes, "properties" ) ) {
			throw(
				type="MissingAttribute",
				message="The 'properties' attribute is required for create action."
			)
		}
		if( !structKeyExists( attributes, "data" ) ) {
			throw(
				type="MissingAttribute",
				message="The 'data' attribute is required for create action."
			)
		}

		// Get optional parameters with defaults
		var columnMap = attributes.columnMap ?: {}
		var feedType = attributes.feedType ?: "rss_2.0"
		var escapeChars = attributes.escapeChars ?: false
		var overwrite = attributes.overwrite ?: false

		// Call FeedUtil.createFeed()
		var feedResult = FeedUtil.createFeed(
			properties = attributes.properties,
			data = attributes.data,
			columnMap = columnMap,
			feedType = feedType,
			escapeChars = escapeChars
		)

		// Store XML in variable if xmlVar specified
		if( structKeyExists( attributes, "xmlVar" ) ) {
			ExpressionInterpreter.setVariable( context, attributes.xmlVar, feedResult.xml );
		}

		// Write to file if outputFile specified
		if( structKeyExists( attributes, "outputFile" ) ) {
			var filePath = attributes.outputFile

			// Check if file exists and overwrite is false
			if( fileExists( filePath ) && !overwrite ) {
				throw(
					type="FileExists",
					message="File '#filePath#' already exists. Set overwrite=true to replace it."
				)
			}

			// Write the XML to file
			fileWrite( filePath, feedResult.xml )
		}

		// Store result struct if result attribute specified
		if( structKeyExists( attributes, "result" ) ) {
			var resultData = {
				xml: feedResult.xml,
				feedType: feedType,
				itemCount: isArray( attributes.data ) ? arrayLen( attributes.data ) : attributes.data.recordCount
			}
			ExpressionInterpreter.setVariable( context, attributes.result, resultData );
		}
	}

}