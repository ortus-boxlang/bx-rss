/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java:com.apptasticsoftware.rssreader.RssReader@bxrss;
import java:com.apptasticsoftware.rssreader.module.itunes.ItunesRssReader@bxrss;
import java:com.apptasticsoftware.rssreader.module.mediarss.MediaRssReader@bxrss;
import java:com.rometools.rome.feed.synd.SyndFeedImpl@bxrss;
import java:com.rometools.rome.feed.synd.SyndEntryImpl@bxrss;
import java:com.rometools.rome.feed.synd.SyndContentImpl@bxrss;
import java:com.rometools.rome.io.SyndFeedOutput@bxrss;

class{

	static {
		rssOb = new RssReader()
		itunesRssOb = new ItunesRssReader()
		mediaRssOb = new MediaRssReader()
		defaultUserAgent = "BoxLang-RSS-Module/1.0 (+https://boxlang.io)"
		defaultTimeout = 25
	}

	/**
	 * Reads RSS feeds from the given URLs with optional filtering, item limit, and auto-detected extension support.
	 *
	 * @param urls A single URL or an array of feed URLs to read.
	 * @param filter A function to filter items; defaults to a function that returns true for all items.
	 * @param maxItems Maximum number of items to return; 0 means no limit.
	 * @param itunes Boolean to force iTunes reader. When false (default), auto-detects iTunes fields if present.
	 * @param mediaRss Boolean to force Media RSS reader. When false (default), auto-detects Media RSS fields if present.
	 * @param userAgent Custom User-Agent string for HTTP requests.
	 * @param timeout Timeout in seconds for HTTP requests.
	 *
	 * @return Struct with 'items' array and 'channel' metadata (extension fields included automatically when present)
	 */
	static function readFeed(
		required urls,
		filter=( i ) -> true,
		numeric maxItems=0,
		boolean itunes=false,
		boolean mediaRss=false,
		string userAgent=static.defaultUserAgent,
		numeric timeout=static.defaultTimeout
	) {

		if( isSimpleValue( urls ) ) urls = [ urls ]

		// Select the appropriate reader based on parameters
		// When neither itunes nor mediaRss is explicitly set, we'll auto-detect by trying iTunes first
		// (since iTunes podcasts are more common than Media RSS)
		var autoDetectExtensions = false
		var reader = static.rssOb

		if( arguments.itunes ) {
			reader = static.itunesRssOb
		} else if( arguments.mediaRss ) {
			reader = static.mediaRssOb
		} else {
			// Auto-detect mode: start with iTunes reader (more common)
			// We'll detect what's actually present and may switch readers if needed
			reader = static.itunesRssOb
			autoDetectExtensions = true
		}

		// Configure timeout if specified (convert seconds to Duration)
		if( arguments.timeout > 0 ) {
			var timeoutDuration = createObject( "java", "java.time.Duration" ).ofSeconds( arguments.timeout )
			reader
				.setConnectionTimeout( timeoutDuration )
				.setRequestTimeout( timeoutDuration )
				.setReadTimeout( timeoutDuration )
		}

		// Configure userAgent if specified
		if( len( arguments.userAgent ) ) {
			reader.setUserAgent( arguments.userAgent )
		}

		// Now read the feeds
		var itemStream = reader
			.read( urls )
			.filter( filter )
			.sorted()

		// Apply maxItems limit if specified
		if( maxItems > 0 ) {
			itemStream = itemStream.limit( maxItems )
		}

		items = itemStream.toList()

		// Auto-detect extension fields if in auto-detect mode
		var hasItunesFields = false
		var hasMediaRssFields = false

		if( autoDetectExtensions && items.size() > 0 ) {
			var firstItem = items[ 1 ]

			// Check for iTunes fields in the first item
			if( !isNull( firstItem.getItunesDuration() ) && firstItem.getItunesDuration().isPresent() ) {
				hasItunesFields = true
			}
			if( !isNull( firstItem.getItunesTitle() ) && firstItem.getItunesTitle().isPresent() ) {
				hasItunesFields = true
			}

			// Check for Media RSS fields in the first item
			// Note: ItunesRssReader won't have getMediaThumbnail(), so we need to check carefully
			try {
				if( !isNull( firstItem.getMediaThumbnail() ) && firstItem.getMediaThumbnail().isPresent() ) {
					hasMediaRssFields = true
				}
			} catch( any e ) {
				// Method doesn't exist on this reader, that's OK
			}

			// Also check channel for iTunes fields
			var channel = firstItem.getChannel()
			if( !isNull( channel ) ) {
				if( !isNull( channel.getItunesImage() ) && len( channel.getItunesImage() ) > 0 ) {
					hasItunesFields = true
				}
				if( !isNull( channel.getItunesCategories() ) && channel.getItunesCategories().size() > 0 ) {
					hasItunesFields = true
				}
			}

			// If no iTunes fields found but we're in auto-detect mode, try Media RSS reader
			if( !hasItunesFields ) {
				// Re-read with Media RSS reader to check for Media RSS fields
				var mediaReader = static.mediaRssOb

				// Configure timeout if specified
				if( arguments.timeout > 0 ) {
					var timeoutDuration = createObject( "java", "java.time.Duration" ).ofSeconds( arguments.timeout )
					mediaReader
						.setConnectionTimeout( timeoutDuration )
						.setRequestTimeout( timeoutDuration )
						.setReadTimeout( timeoutDuration )
				}

				// Configure userAgent if specified
				if( len( arguments.userAgent ) ) {
					mediaReader.setUserAgent( arguments.userAgent )
				}

				// Try reading with Media RSS reader
				var mediaStream = mediaReader.read( urls ).filter( filter ).sorted()
				if( maxItems > 0 ) {
					mediaStream = mediaStream.limit( maxItems )
				}
				var mediaItems = mediaStream.toList()

				// Check if Media RSS fields are present
				if( mediaItems.size() > 0 ) {
					var mediaFirstItem = mediaItems[ 1 ]
					if( !isNull( mediaFirstItem.getMediaThumbnail() ) && mediaFirstItem.getMediaThumbnail().isPresent() ) {
						hasMediaRssFields = true
						// Use the Media RSS items instead
						items = mediaItems
					}
				}
			}

			// Update the flags based on what we detected
			arguments.itunes = hasItunesFields
			arguments.mediaRss = hasMediaRssFields
		}

		// Extract channel metadata from first item (all items share the same channel)
		var channelInfo = {}
		if( items.size() > 0 ) {
			var channel = items[ 1 ].getChannel()
			if( !isNull( channel ) ) {
				channelInfo = {
					title: isNull( channel.getTitle() ) ? '' : channel.getTitle(),
					description: isNull( channel.getDescription() ) ? '' : channel.getDescription(),
					link: isNull( channel.getLink() ) ? '' : channel.getLink(),
					language: channel.getLanguage().orElse( '' ),
					copyright: channel.getCopyright().orElse( '' ),
					lastBuildDate: channel.getLastBuildDate().orElse( '' ),
					generator: channel.getGenerator().orElse( '' ),
					image: ''
				}

				// Get channel image if available
				channel.getImage().ifPresent( img => {
					var imgUrl = img.getUrl()
					channelInfo.image = isNull( imgUrl ) || !len( imgUrl ) ? '' : imgUrl
				} )

				// Add iTunes podcast channel fields if requested
				if( itunes ) {
					channelInfo.itunesImage = isNull( channel.getItunesImage() ) ? '' : channel.getItunesImage()
					channelInfo.itunesCategories = channel.getItunesCategories()
					channelInfo.itunesExplicit = isNull( channel.getItunesExplicit() ) ? false : channel.getItunesExplicit()
					channelInfo.itunesAuthor = channel.getItunesAuthor().orElse( '' )
					channelInfo.itunesTitle = channel.getItunesTitle().orElse( '' )
					channelInfo.itunesSubtitle = channel.getItunesSubtitle().orElse( '' )
					channelInfo.itunesSummary = isNull( channel.getItunesSummary() ) ? '' : channel.getItunesSummary()
					channelInfo.itunesType = channel.getItunesType().orElse( '' )
					channelInfo.itunesNewFeedUrl = channel.getItunesNewFeedUrl().orElse( '' )
					channelInfo.itunesBlock = channel.isItunesBlock()
					channelInfo.itunesComplete = channel.isItunesComplete()

					// iTunes owner
					channel.getItunesOwner().ifPresent( owner => {
						channelInfo.itunesOwner = {
							name: owner.getName().orElse( '' ),
							email: isNull( owner.getEmail() ) ? '' : owner.getEmail()
						}
					} )

					// Default empty owner if not present
					if( !structKeyExists( channelInfo, 'itunesOwner' ) ) {
						channelInfo.itunesOwner = { name: '', email: '' }
					}
				}

				// Detect feed specifications and extensions
				channelInfo.specs = detectFeedSpecs( items[ 1 ], itunes, mediaRss )
			}
		}

		var mappedItems = items.map( i => {
			var result = {
				title: '',
				content: '',
				description: '',
				pubdate: '',
				updated: '',
				link: '',
				author: '',
				category: '',
				categories: [],
				guid: '',
				isPermaLink: '',
				comments: '',
				enclosures: [],
				channelTitle: ''
			}

			// Add iTunes-specific fields if requested
			if( itunes ) {
				result.itunesDuration = ''
				result.itunesExplicit = false
				result.itunesTitle = ''
				result.itunesSubtitle = ''
				result.itunesSummary = ''
				result.itunesKeywords = ''
				result.itunesEpisode = 0
				result.itunesSeason = 0
				result.itunesEpisodeType = ''
				result.itunesImage = ''
				result.itunesBlock = false
			}

			// Add Media RSS fields if requested
			if( mediaRss ) {
				result.mediaThumbnail = {
					url: '',
					width: 0,
					height: 0,
					time: ''
				}
			}

			i.getTitle().ifPresent( t => result.title = t )
			i.getLink().ifPresent( l => result.link = l )
			i.getContent().ifPresent( c => result.content = c )
			i.getDescription().ifPresent( d => result.description = d )
			i.getAuthor().ifPresent( a => result.author = a )
			i.getCategory().ifPresent( c => result.category = c )
			i.getGuid().ifPresent( g => result.guid = g )
			i.getComments().ifPresent( c => result.comments = c )
			i.getIsPermaLink().ifPresent( p => result.isPermaLink = p )

			// Get all categories (returns a List)
			var cats = i.getCategories()
			if( !isNull( cats ) && cats.size() > 0 ) {
				result.categories = cats
			}

			// Get all enclosures (returns a List)
			var encs = i.getEnclosures()
			if( !isNull( encs ) && encs.size() > 0 ) {
				result.enclosures = encs.stream().map( e => {
					return {
						url: isNull( e.getUrl() ) ? '' : e.getUrl(),
						type: isNull( e.getType() ) ? '' : e.getType(),
						length: e.getLength().orElse( 0 )
					}
				} ).toList()
			}

			// getChannel() returns a Channel object, getTitle() on Channel returns String directly
			var channel = i.getChannel()
			if( !isNull( channel ) ) {
				var channelTitle = channel.getTitle()
				if( !isNull( channelTitle ) && len( channelTitle ) ) {
					result.channelTitle = channelTitle
				}
			}

			i.getPubDateZonedDateTime().ifPresent( d => {
				result.pubdate = parseDateTime( d )
			} )

			i.getUpdatedZonedDateTime().ifPresent( d => {
				result.updated = parseDateTime( d )
			} )

			// Extract iTunes podcast fields if enabled
			if( itunes ) {
				i.getItunesDuration().ifPresent( d => result.itunesDuration = d )
				result.itunesExplicit = i.isItunesExplicit()
				i.getItunesTitle().ifPresent( t => result.itunesTitle = t )
				i.getItunesSubtitle().ifPresent( s => result.itunesSubtitle = s )
				i.getItunesSummary().ifPresent( s => result.itunesSummary = s )
				i.getItunesKeywords().ifPresent( k => result.itunesKeywords = k )
				i.getItunesEpisode().ifPresent( e => result.itunesEpisode = e )
				i.getItunesSeason().ifPresent( s => result.itunesSeason = s )
				i.getItunesEpisodeType().ifPresent( t => result.itunesEpisodeType = t )
				i.getItunesImage().ifPresent( img => result.itunesImage = img )
				result.itunesBlock = i.isItunesBlock()
			}

			// Extract Media RSS fields if enabled
			if( mediaRss ) {
				i.getMediaThumbnail().ifPresent( thumb => {
					result.mediaThumbnail = {
						url: thumb.getUrl(),
						width: thumb.getWidth().orElse( 0 ),
						height: thumb.getHeight().orElse( 0 ),
						time: thumb.getTime().orElse( '' )
					}
				} )
			}

			return result
		} )

		return {
			"items": mappedItems,
			"channel": channelInfo
		}
    }

	/**
	 * Detect feed specifications, type, version, and extensions
	 *
	 * @item First item from the feed to inspect
	 * @itunes Whether iTunes extensions are enabled
	 * @mediaRss Whether Media RSS extensions are enabled
	 *
	 * @return Struct with feed specifications: type, version, extensions, generator, ttl, hasDateFields
	 */
	static function detectFeedSpecs(
		required item,
		boolean itunes = false,
		boolean mediaRss = false
	) {
		var specs = {
			type: "",
			version: "",
			extensions: [],
			generator: "",
			ttl: 0,
			hasDateFields: false
		}

		// Detect feed type by inspecting item class
		var itemClassName = item.getClass().getName()
		if( itemClassName.contains( "Rss" ) ) {
			specs.type = "RSS"
			// RSS 2.0 is most common, library doesn't expose version directly
			specs.version = "2.0"
		} else if( itemClassName.contains( "Atom" ) ) {
			specs.type = "Atom"
			specs.version = "1.0"
		} else if( itemClassName.contains( "Rdf" ) ) {
			specs.type = "RSS"
			specs.version = "1.0"
		}

		// Detect extensions based on available fields
		if( itunes ) {
			specs.extensions.append( "iTunes Podcast" )
		}
		if( mediaRss ) {
			specs.extensions.append( "Media RSS" )
		}

		// Check for Dublin Core namespace (common extension)
		if( !isNull( item.getCreator() ) && len( item.getCreator().orElse( "" ) ) ) {
			if( !specs.extensions.find( "Dublin Core" ) ) {
				specs.extensions.append( "Dublin Core" )
			}
		}

		// Detect date field presence
		if( !isNull( item.getPubDate() ) || !isNull( item.getPublished() ) ) {
			specs.hasDateFields = true
		}

		return specs
	}

	/**
	 * Creates an RSS or Atom feed from the given properties and data.
	 *
	 * @param properties Struct containing feed metadata (title, description, link, etc.)
	 * @param data Array or Query of feed items/entries
	 * @param columnMap Struct mapping query columns to feed item fields (optional, for query data)
	 * @param feedType Feed type: "rss_2.0" (default), "atom_1.0", etc.
	 * @param escapeChars Boolean to escape special characters for W3C compliance (default false)
	 *
	 * @return Struct with 'xml' (feed XML string) and 'feedObject' (SyndFeed instance)
	 */
	static function createFeed(
		required struct properties,
		required data,
		struct columnMap = {},
		string feedType = "rss_2.0",
		boolean escapeChars = false
	) {
		// Create feed object
		var feed = new SyndFeedImpl()
		feed.setFeedType( arguments.feedType )

		// Set feed properties from properties struct
		if( structKeyExists( arguments.properties, "title" ) ) {
			feed.setTitle( arguments.properties.title )
		}
		if( structKeyExists( arguments.properties, "link" ) ) {
			feed.setLink( arguments.properties.link )
		}
		if( structKeyExists( arguments.properties, "description" ) ) {
			feed.setDescription( arguments.properties.description )
		}
		if( structKeyExists( arguments.properties, "author" ) ) {
			feed.setAuthor( arguments.properties.author )
		}
		if( structKeyExists( arguments.properties, "language" ) ) {
			feed.setLanguage( arguments.properties.language )
		}
		if( structKeyExists( arguments.properties, "copyright" ) ) {
			feed.setCopyright( arguments.properties.copyright )
		}
		if( structKeyExists( arguments.properties, "publishedDate" ) ) {
			// Convert to Java Date - Rome expects java.util.Date
			// BoxLang DateTime objects have toDate() method
			var pubDate = arguments.properties.publishedDate
			if( !(pubDate instanceof "DateTime") ) {
				pubDate = parseDateTime( pubDate )
			}
			feed.setPublishedDate( pubDate.toDate() )
		}

		// Create Java ArrayList for entries
		var ArrayList = createObject( "java", "java.util.ArrayList" )
		var entries = ArrayList.init()
		var itemData = isArray( arguments.data ) ? arguments.data : queryToArray( arguments.data )

		for( var item in itemData ) {
			var entry = new SyndEntryImpl()

			// Map fields based on columnMap or direct struct keys
			var titleField = structKeyExists( arguments.columnMap, "title" ) ? arguments.columnMap.title : "title"
			var linkField = structKeyExists( arguments.columnMap, "link" ) ? arguments.columnMap.link : "link"
			var descField = structKeyExists( arguments.columnMap, "description" ) ? arguments.columnMap.description : "description"
			var contentField = structKeyExists( arguments.columnMap, "content" ) ? arguments.columnMap.content : "content"
			var authorField = structKeyExists( arguments.columnMap, "author" ) ? arguments.columnMap.author : "author"
			var pubDateField = structKeyExists( arguments.columnMap, "publishedDate" ) ? arguments.columnMap.publishedDate : "publishedDate"
			var categoryField = structKeyExists( arguments.columnMap, "category" ) ? arguments.columnMap.category : "category"

			// Set entry fields
			if( structKeyExists( item, titleField ) ) {
				entry.setTitle( escapeChars ? xmlFormat( item[ titleField ] ) : item[ titleField ] )
			}
			if( structKeyExists( item, linkField ) ) {
				entry.setLink( item[ linkField ] )
			}
			if( structKeyExists( item, authorField ) ) {
				entry.setAuthor( item[ authorField ] )
			}
			if( structKeyExists( item, pubDateField ) ) {
				// Rome expects java.util.Date, BoxLang DateTime has toDate() method
				var itemPubDate = item[ pubDateField ]
				if( !(itemPubDate instanceof "DateTime") ) {
					itemPubDate = parseDateTime( itemPubDate )
				}
				entry.setPublishedDate( itemPubDate.toDate() )
			}

			// Set description/content
			if( structKeyExists( item, descField ) || structKeyExists( item, contentField ) ) {
				var description = new SyndContentImpl()
				description.setType( "text/html" )

				var contentText = structKeyExists( item, contentField ) ? item[ contentField ] : item[ descField ]
				description.setValue( escapeChars ? xmlFormat( contentText ) : contentText )

				entry.setDescription( description )
			}

			// Add categories if present
			if( structKeyExists( item, categoryField ) ) {
				var catArrayList = ArrayList.init()
				var categoryValue = item[ categoryField ]

				// Handle comma-separated list or array
				if( isSimpleValue( categoryValue ) ) {
					categoryValue = listToArray( categoryValue )
				}

				for( var cat in categoryValue ) {
					var SyndCategoryImpl = createObject( "java", "com.rometools.rome.feed.synd.SyndCategoryImpl@bxrss" )
					var category = SyndCategoryImpl.init()
					category.setName( trim( cat ) )
					catArrayList.add( category )
				}

				entry.setCategories( catArrayList )
			}

			entries.add( entry )
		}

		feed.setEntries( entries )

		// Generate XML output
		var output = new SyndFeedOutput()
		var xmlString = output.outputString( feed )

		return {
			"xml": xmlString,
			"feedObject": feed
		}
	}	/**
	 * Helper to convert query to array of structs
	 */
	private static function queryToArray( required query q ) {
		var result = []
		for( var row in q ) {
			result.append( row )
		}
		return result
	}
}